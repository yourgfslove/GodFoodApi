// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package database

import (
	"context"
	"database/sql"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, hash_password, user_role, phone, created_at, address, user_name)
VALUES (
        $1,
        $2,
        $3,
        $4,
        NOW(),
        $5,
        $6
)
RETURNING id, email, hash_password, user_role, created_at, phone, address, user_name
`

type CreateUserParams struct {
	Email        string
	HashPassword string
	UserRole     string
	Phone        string
	Address      sql.NullString
	UserName     sql.NullString
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Email,
		arg.HashPassword,
		arg.UserRole,
		arg.Phone,
		arg.Address,
		arg.UserName,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.HashPassword,
		&i.UserRole,
		&i.CreatedAt,
		&i.Phone,
		&i.Address,
		&i.UserName,
	)
	return i, err
}

const getNameByID = `-- name: GetNameByID :one
SELECT user_name FROM users
WHERE id=$1
`

func (q *Queries) GetNameByID(ctx context.Context, id int32) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getNameByID, id)
	var user_name sql.NullString
	err := row.Scan(&user_name)
	return user_name, err
}

const getRestaurantAndMenuByID = `-- name: GetRestaurantAndMenuByID :many
SELECT
    users.id AS restaurant_id,
    users.user_name AS restaurant_name,
    users.address AS restaurant_address,
    users.phone AS restaurant_phone,

    menuitem.id AS menu_item_ID,
    menuitem.name AS menu_item_name,
    menuitem.price,
    menuitem.description,
    menuitem.available

FROM users
JOIN menuitem ON users.id = menuitem.restaurant_id
WHERE users.id = $1 AND users.user_role = 'restaurant'
`

type GetRestaurantAndMenuByIDRow struct {
	RestaurantID      int32
	RestaurantName    sql.NullString
	RestaurantAddress sql.NullString
	RestaurantPhone   string
	MenuItemID        int32
	MenuItemName      string
	Price             float64
	Description       sql.NullString
	Available         sql.NullBool
}

func (q *Queries) GetRestaurantAndMenuByID(ctx context.Context, id int32) ([]GetRestaurantAndMenuByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getRestaurantAndMenuByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRestaurantAndMenuByIDRow
	for rows.Next() {
		var i GetRestaurantAndMenuByIDRow
		if err := rows.Scan(
			&i.RestaurantID,
			&i.RestaurantName,
			&i.RestaurantAddress,
			&i.RestaurantPhone,
			&i.MenuItemID,
			&i.MenuItemName,
			&i.Price,
			&i.Description,
			&i.Available,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, hash_password, user_role, created_at, phone, address, user_name FROM users
WHERE email=$1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.HashPassword,
		&i.UserRole,
		&i.CreatedAt,
		&i.Phone,
		&i.Address,
		&i.UserName,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, hash_password, user_role, created_at, phone, address, user_name FROM users
WHERE id=$1
`

func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.HashPassword,
		&i.UserRole,
		&i.CreatedAt,
		&i.Phone,
		&i.Address,
		&i.UserName,
	)
	return i, err
}

const getUsersByRole = `-- name: GetUsersByRole :many
SELECT id, email, hash_password, user_role, created_at, phone, address, user_name FROM users
WHERE user_role=$1
`

func (q *Queries) GetUsersByRole(ctx context.Context, userRole string) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getUsersByRole, userRole)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.HashPassword,
			&i.UserRole,
			&i.CreatedAt,
			&i.Phone,
			&i.Address,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
